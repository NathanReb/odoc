<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>dune (odoc.dune)</title><link rel="stylesheet" href="odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">odoc</a> &#x00BB; dune</nav><header class="odoc-preamble"><h1 id="dune-and-odoc"><a href="#dune-and-odoc" class="anchor"></a>Dune and odoc</h1></header><nav class="odoc-toc"><ul><li><a href="#using_dune">Using Dune</a></li><li><a href="#library_wrapping">Dune's library wrapping</a></li><li><a href="#example">Example</a><ul><li><a href="#hand-written-top-level-module">Hand-written top-level module</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="using_dune"><a href="#using_dune" class="anchor"></a>Using Dune</h2><p>To create docs with <code>odoc</code> and Dune is straightforward, but there is an important point to know: Dune only creates docs for <em>public packages</em>. So you will need a <code>(public_name ...)</code> stanza in your libraries and a corresponding <code>lib.opam</code> file in the root of your project.</p><p>As a simple example, the given the following files:</p><ul><li><p><code>dune-project</code></p><pre><code>(lang dune 2.0)</code></pre></li><li><p><code>dune</code></p><pre><code>(library
  (public_name lib))</code></pre></li><li><p><code>a.ml</code></p><pre><code>(** Module A *)

type t = int (** My type *)</code></pre></li><li><code>lib.opam</code> - this file need only <em>exist</em>, ie, <code>touch lib.opam</code> is sufficient.</li></ul><p>To use dune to create the docs for these:</p><pre><code>$ dune build @doc</code></pre><p>and the results will be in <code>_build/default/_doc/_html/</code>.</p><h2 id="library_wrapping"><a href="#library_wrapping" class="anchor"></a>Dune's library wrapping</h2><p>Dune has a feature whereby a library may be exposed under a single top-level module. This makes use of a feature of OCaml where the use of the compiler flag <code>-no-alias-deps</code> is used to avoid introducing dependencies between compilation units.</p><p>The aim is to reduce the number of potential name clashes of modules by only exposing one main module the users of the library are intended to use, and exposing the modules that comprise the library as submodules, while still retaining the usual way of writing OCaml code with one module per file. These individual files are still compiled and installed -- and available in the global namespace -- but their names are prefixed with the name of the library in order to reduce the possibility of clashes.</p><p>Dune includes canonical tags for these modules to allow for odoc to produce correct documentation.</p><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><p>Given two modules, <code>A</code> and <code>B</code>, with <code>B</code> referencing types declared in module <code>A</code>:</p><pre><code>(** Module A *)
type t</code></pre><pre><code>(** Module B *)
type t = A.t</code></pre><p>If these modules are to become part of a library called <code>Lib</code>, then dune will compile these two as if their names were <code>Lib__A</code> and <code>Lib__B</code> and also create a file <code>lib.ml</code> containing the following:</p><pre><code>(** @canonical Lib.A *)
module A = Lib__A

(** @canonical Lib.B *)
module B = Lib__B</code></pre><p>This is the module that will be the one module intended to be used directly by users of the library. This module is in fact compiled <em>first</em>, using the compiler flag <code>--no-alias-deps</code>, which allows it to be compiled without requiring <code>Lib__A</code> and <code>Lib__B</code> to be compiled first.</p><p>Dune will then compile <code>a.ml</code> and <code>b.ml</code> in that order, but ask the compiler to name them <code>Lib__A</code> and <code>Lib__B</code>. It also 'opens' the module <code>Lib</code>, which is what allows <code>B</code> to refer to <code>A.t</code>.</p><p>When odoc is used to produce documentation for this, firstly all modules are compiled, but only one module is considered to be visible - <code>Lib</code>. All others have double underscores meaning they are hidden. Only the non-hidden module <code>Lib</code> is linked, and during this process the the modules <code>A</code> and <code>B</code> are expanded because they are aliases of hidden modules. All references to <code>Lib__A</code> and <code>Lib__B</code> are replaced with the canonical paths <code>Lib.A</code> and <code>Lib.B</code>, and in this way odoc presents the library as entirely containined withing the module <code>Lib</code>.</p><h3 id="hand-written-top-level-module"><a href="#hand-written-top-level-module" class="anchor"></a>Hand-written top-level module</h3><p>In some cases it is desirable to hand-write the top-level library module. This is usually done because some of the modules within the library are intended to be internal only, and not exposed. Dune will notice that a module exists with the name of the library (<code>lib.ml</code> in this case) and instead it will create the file <code>lib__.ml</code>. The contents of this are identical to the previous section, with aliases for all modules. The canonical tags on the aliases are, as before, to <code>Lib.A</code> and <code>Lib.B</code>. These are references to module aliases that should be present in <code>lib.ml</code>. If these are <em>not</em> there, odoc will not be able to resolve the canonical references, and any items from these modules that are exposed elsewhere will be hidden. If the items are type aliases they can be replaced, but otherwise they will be rendered as unresolved links.</p><p>For example, consider the following module structure. First, the module <code>Unexposed</code> in file <code>unexposed.mli</code></p><pre><code>(** Unexposed module *)

type t</code></pre><p>The module <code>Wrapping</code>, in file <code>wrapping.mli</code>:</p><pre><code>(** Example of dune's wrapping *)

type t = Unexposed.t

val f : Unexposed.t</code></pre><p>and the library module that only exposes the module <code>Wrapping</code>:</p><pre><code>module Wrapping = Wrapping</code></pre><p>This structure is rendered <a href="odoc_examples/Odoc_examples/Wrapping/index.html">here</a>.</p></div></body></html>