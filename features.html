<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>features (odoc.features)</title><link rel="stylesheet" href="odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">odoc</a> &#x00BB; features</nav><header class="odoc-preamble"><h1 id="language-features"><a href="#language-features" class="anchor"></a>Language features</h1><p>Odoc works by taking module interfaces, processing them to make them more useful, and turning them into documentation. The processing that odoc does is largely <a href="#hiding">hiding</a>, handling of <a href="#canonical">canonical references</a>, <a href="#expansion">expansion</a> and <a href="#resolution">resolution</a>, and this document explains the features of these processes in detail.</p></header><nav class="odoc-toc"><ul><li><a href="#hiding">Hiding</a></li><li><a href="#canonical">Canonical items</a></li><li><a href="#expansion">Expansion</a><ul><li><a href="#aliases">Aliases</a><ul><li><a href="#module-type-aliases">Module type aliases</a></li></ul></li><li><a href="#functors">Functors</a></li><li><a href="#includes">Includes</a></li><li><a href="#shadowing">Shadowing</a></li><li><a href="#deep-equations">Deep equations</a></li><li><a href="#substitution">Substitution</a></li><li><a href="#module_type_of"><code>module type of</code></a></li><li><a href="#complications-of-module-type-of">Complications of <code>module type of</code></a></li></ul></li><li><a href="#resolution">Resolution</a><ul><li><a href="#aliases">Aliases</a></li><li><a href="#canonical-paths">Canonical paths</a></li><li><a href="#fragment-resolution">Fragment resolution</a></li><li><a href="#hidden-elements">Hidden elements</a></li><li><a href="#reference-resolution">Reference resolution</a></li><li><a href="#module-type-challenges">Module type challenges</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="hiding"><a href="#hiding" class="anchor"></a>Hiding</h2><p>Some items are not intended to be used directly but are present as implementation detail, for example for testing, or for implementing dune's namespacing, or other reasons.</p><p>There are two mechanisms for explicitly hiding elements from the final output. The first is to use <a href="https://ocaml.org/manual/ocamldoc.html#ss:ocamldoc-stop">documentation stop comments</a>, which can be used to hide any items at all from the output. The second mechanism is only used for modules, and is a naming convention. If any module has a double underscore in its name, it is considered to be hidden.</p><h2 id="canonical"><a href="#canonical" class="anchor"></a>Canonical items</h2><p>Occasionally it is useful to declare an item in one place, and expose it in the public interface in another. In order to prevent unwanted occurrences of the actual definition site, odoc has a feature whereby the 'canonical' location of a module, module type or type can be specified.</p><p>The biggest user of module aliases is dune's <a href="https://dune.readthedocs.io/en/stable/dune-files.html#library">wrapped libraries</a>. This feature allows dune to produce a library whose interface is exposed entirely though a single top-level module. It does this by mangling the names of the real implementation modules and generating the single top-level module that simply contains aliases to the these implementation modules. With odoc's canonical modules feature all references to the implementation modules are rewritten to point at the aliases in the top-level module instead. Please see the section on Dune's <a href="dune.html#library_wrapping">library wrapping</a> for more detail.</p><p>In a similar fashion, it is sometimes useful to have this feature on module types and types. For example, odoc itself uses this for it's 'paths types'. Since they are all mutually recursive they have to be declared all at the same time in the module <a href="https://github.com/ocaml/odoc/blob/91f6310967e64f3fa88445f3daf2fea2acc0bb49/src/model/paths_types.ml#L201-L219"><code>Paths_types</code></a>, but odoc exposes them in separate modules. By annotating the definition point with <code>@canonical</code> tags pointing to the <a href="https://github.com/ocaml/odoc/blob/master/src/model/paths.mli#L419">aliases</a>, we ensure that all references to them point at the <a href="odoc_model/Odoc_model/Paths/Path/Resolved/Module/index.html">separate</a> <a href="odoc_model/Odoc_model/Paths/Path/Resolved/ModuleType/index.html">modules</a> as intended.</p><h2 id="expansion"><a href="#expansion" class="anchor"></a>Expansion</h2><p>There are many instances of items in signatures where what's written is the best thing in terms of semantics, but not necessarily useful in terms of documentation. For example:</p><pre><code>module StringSet : Stdlib.Set.S with type t = string</code></pre><p>Odoc will <em>expand</em> these items, augmenting the declaration with the signature along with all the documentation comments that can be found, so in this case those from <code>Stdlib.Set.S</code>. While the compiler also does a very similar procedure and determines the signature of the module, odoc tries quite hard to preserve as much as possible from the context of the original items.</p><p>The declaration can be seen rendered <a href="odoc_examples/Odoc_examples/Expansion/Simple/index.html">here</a>, and the full expansion can be found by clicking on the name of the module (<code>StringSet</code> in this case), or the direct link is <a href="odoc_examples/Odoc_examples/Expansion/Simple/StringSet/index.html">here</a>.</p><p>These expansions have to be done carefully. A number of cases follow in which odoc has to treat specially.</p><h3 id="aliases"><a href="#aliases" class="anchor"></a>Aliases</h3><p>In general odoc does not expand module aliases, unless they are an alias to a hidden module. If this is the case the right-hand side of the declaration is dropped and replaced with <code>sig ... end</code> and the expansion is created.</p><p>For example, given the following source,</p><pre><code>module Hidden__module : sig
  type t
  val f : t -&gt; t
end

module Alias = Hidden__module</code></pre><p>then the <code>Hidden__module</code> module will not be present in the output, and the <code>Alias</code> module will be rendered as if it were a simple signature. This can be seen in the example rendering <a href="odoc_examples/Odoc_examples/Expansion/Aliases/index.html">here</a>.</p><p>As well as expanding aliases to hidden modules, modules are also expanded if the module alias is &quot;self canonical&quot; - that is, if module <code>A</code> is an alias to another module <code>B</code> that declares <code>A</code> to be the canonical path to the module (ie, it has the tag <code>@canonical A</code> in an associated comment).</p><h4 id="module-type-aliases"><a href="#module-type-aliases" class="anchor"></a>Module type aliases</h4><p>Module types do not have aliases in the same way that modules do, but it is possible and common to declare an effective alias to another by simply creating a new module type that is equal to a previous one. For example:</p><pre><code>module type A = sig
  type t
end

module type B = A</code></pre><p>For these simple module type declarations where the right-hand side is just a path, odoc treats them as module aliases and does not produce an expansion. This example is rendered <a href="odoc_examples/Odoc_examples/Expansion/ModuleTypeAliases/index.html">here</a>.</p><p>When strengthening, OCaml creates turns modules into aliases to the original module, but nothing is done to module types. In contrast, odoc replaces module types with 'aliases' to the originals too - these are then not expanded and hence this is important for reducing the size of the output.</p><p>The following examples uses <code>module type of struct include ... end</code> to obtain the strengthened signature of <code>A</code> (see the <a href="#module_type_of"><code>Module Type Of</code></a> section for more discussion of this).</p><pre><code>module A : sig
  module type A = sig type t end
  module X : A
end
module B : module type of struct include A end</code></pre><p>OCaml evaluates the following signature for <code>B</code>:</p><pre><code>module B : sig module type A = sig type t end module X = A.X end</code></pre><p>whereas odoc internally evaluates this as:</p><pre><code>module B : sig module type A = A.A end module X = A.X end</code></pre><p>This example is rendered <a href="odoc_examples/Odoc_examples/Expansion/ModuleTypeAliases2/B/index.html">here</a></p><h3 id="functors"><a href="#functors" class="anchor"></a>Functors</h3><p>When odoc encounters a functor, these are also expanded. The parameters are expanded in the body of the functor expansion above the signature representing the result of the functor.</p><p>For example, given the following:</p><pre><code>module type Argument = sig

  (** This type [a] is declared in the Argument module type *)
  type a

end

module type Result = sig

  (** This type [r] is declared in the Result module type *)
  type r

end

module Functor : functor (X : Argument) (Y : Argument) -&gt; Result</code></pre><p>an expansion will be created for <code>Functor</code>, containing within it expansions for <code>X</code> and <code>Y</code>, followed by the signature of <code>Result</code>. The above functor can be seen rendered <a href="odoc_examples/Odoc_examples/Expansion/Functors/Functor/index.html">here</a>.</p><h3 id="includes"><a href="#includes" class="anchor"></a>Includes</h3><p>If part of your module signature comes from an include of another module or module type, <code>odoc</code> keeps track of this and can render the included items in a clearly delimited and collapsible way. For example, given the following:</p><pre><code>module type ToBeIncluded = sig
    type t

    val f : t -&gt; t
    (** The description of [f] *)
end

module A : sig
    include ToBeIncluded

    val g : t -&gt; t
end</code></pre><p>The <a href="odoc_examples/Odoc_examples/Expansion/Include/A/index.html">expansion of module <code>A</code></a> will contain a clearly demarcated section showing the included items.</p><p>If this behaviour is not desired, the include may be inlined with the tag <code>@inline</code> as follows:</p><pre><code>module B : sig
    include ToBeIncluded
    (** @inline *)

    val g : t -&gt; t
end</code></pre><p>The <a href="odoc_examples/Odoc_examples/Expansion/Include/B/index.html">expansion of module <code>B</code></a> does not contain an indication that the elements <code>t</code> and <code>f</code> came from an <code>include</code> directive.</p><h3 id="shadowing"><a href="#shadowing" class="anchor"></a>Shadowing</h3><p>OCaml ordinarily does not allow two items of the same type with the same name. For example, the following is illegal:</p><pre><code>type t = int
type t = string</code></pre><p>However, if the item comes in via an include, then OCaml allows it. For example,</p><pre><code>module type A = sig
  type t = int
  val f : t
end

module type B = sig
  include A
  type t = string
  val g : t
end</code></pre><p>Since odoc is required to do its own expansions, it must take account of this behaviour. The previous example is rendered <a href="odoc_examples/Odoc_examples/Expansion/Shadowing/index.html">here</a>.</p><h3 id="deep-equations"><a href="#deep-equations" class="anchor"></a>Deep equations</h3><p>The module type system allows for adding equations to abstract types (as seen above in the <code>StringSet</code> declaration). These equations may be 'deep' in the sense that they operate on a nested module rather than the outer one. For example,</p><pre><code>module type SIG = sig
  type t
end

module type MODTYPE = sig
  module X : SIG
  module Y : SIG
end

type foo

module M : MODTYPE with type X.t = foo</code></pre><p>Here we've got a module type <code>SIG</code> that contains an abstract type <code>t</code>. Then a module type <code>MODTYPE</code> that contains two modules, <code>X</code> and <code>Y</code>, that have signature <code>SIG</code>. Lastly we declare a module <code>M</code> that has signature <code>MODTYPE</code> with an additional type equality <code>X.t = foo</code>. When the compiler evaluates the signature of module <code>M</code> here, the definition of <code>X</code> within it is simply replaced with a signature:</p><pre><code>module M : sig
  module X : sig type t = foo end
  module Y : SIG
end</code></pre><p>and we lose both the fact that it came from <code>MODTYPE</code> and also that within it <code>X</code> originally had signature <code>SIG</code>. Odoc tries to be more careful and instead with keep both the <code>MODTYPE</code> on <code>M</code> with the type equality <code>X.t = foo</code>, and the <code>SIG</code> on <code>X</code> with the type equality <code>t = foo</code>. The expansion of of module M in this example can be seen <a href="odoc_examples/Odoc_examples/Expansion/DeepEquality/M/index.html">here</a>.</p><p>Note that if X was a simple signature before the type equality was added, that does not get preserved. In the following example,</p><pre><code>module type MODTYPE = sig
    module X : sig type t end
    module Y : sig type t end
end

type foo

module M : MODTYPE with type X.t = foo</code></pre><p>the <a href="odoc_examples/Odoc_examples/Expansion/DeepEquality2/M/index.html">expansion of M</a> does not contain any <code>with type</code> equations.</p><h3 id="substitution"><a href="#substitution" class="anchor"></a>Substitution</h3><p>Similar to the addition of equations in the previous section, OCaml allows for types and modules to be <em>destructively</em> substituted - so that the type or module is entirely removed from the resulting signature.</p><p>As with the addition of equations above, these substitutions may be on deeply nested modules, and care needs to be taken to ensure that there are no references to the removed module or type left. For example,</p><pre><code>module type S = sig
  module M: sig type t end

  type t = M.t
end

module type T = S with type M.t := int</code></pre><p>The expansion of <code>T</code> internally is different from what is rendered. Internally, it becomes:</p><pre><code>module M: sig type t end with type t := int

type t = M.t</code></pre><p>From this expansion it is still clear how to resolve the right-hand side of <code>type t = M.t</code>, and the next phase of odoc's transformation turns the right-hand side of <code>M.t</code> into <code>int</code>.</p><p>In the output documentation, the declaration of `module M` is rendered simply as</p><pre><code>module M : sig ... end</code></pre><p>with the type substitution dropped. This is because the type substitition on the simple signature is not useful to know to the reader; the link <code>t</code> would have no destination. This example is rendered <a href="odoc_examples/Odoc_examples/Expansion/TypeSubstitution/index.html">here</a>.</p><h3 id="module_type_of"><a href="#module_type_of" class="anchor"></a><code>module type of</code></h3><p>The OCaml construct <code>module type of</code> allows the type of a module to be recovered. As usual, when OCaml performs this operation it only retains the simplified signature, stripped of comments, includes, and more complex module type expressions. As with the previous sections, odoc tries a little harder to keep track of these things, and also of the fact that the signature came from a <code>module type of</code> expression.</p><p>For example, consider the following:</p><pre><code>module A : sig

  (** This comment for [type t] is written in module [A] *)
  type t

end

module M : module type of A</code></pre><p>the <code>type t</code> in module <code>M</code> has the comment from the original module. There is also logic in odoc to manage the similar construct <code>module type of struct include ... end</code> which is used where the types and modules are required to be strengthened - that is, the types in the signature are equal to those in the original module, and any modules in the new signature are aliases of those in the original. For example,</p><pre><code>module M' : module type of struct include A end</code></pre><p>In <a href="odoc_examples/Odoc_examples/Expansion/ModuleTypeOf/M/index.html">M'</a>, type <code>t</code> is equal to <code>A.t</code>, whereas in <a href="odoc_examples/Odoc_examples/Expansion/ModuleTypeOf/M/index.html">M</a> there is no equation.</p><h3 id="complications-of-module-type-of"><a href="#complications-of-module-type-of" class="anchor"></a>Complications of <code>module type of</code></h3><p>Doing the expansion like this comes with some complications, particularly when the result is further modified. For example, consider this example:</p><pre><code>module type S = sig
  module X : sig
    type t
  end

  module type Y = module type of X
  module type Z = module type of struct include X end
end</code></pre><p>When OCaml operates on this, it calculates the signature of <code>S</code> immediately, resulting in the module type:</p><pre><code>module type S =
  sig
    module X : sig type t end
    module type Y = sig type t end
    module type Z = sig type t = X.t end
  end</code></pre><p>whereas odoc preserves the fact that <code>Y</code> and <code>Z</code> are calculated from <code>X</code>. If the module <code>X</code> is subsequently replaced using a destructive substitution on <code>S</code>, the results would be different. Given the following,</p><pre><code>module X1 : sig
  type t
  type u
end

module type T = S with module X := X1</code></pre><p>then the signature of T as calculated by OCaml will be</p><pre><code>sig
    module type Y = sig type t end
    module type Z = sig type t = X1.t end
end</code></pre><p>However it's clear that if the <code>module type of</code> operations were evaluated <em>after</em> the substitution, both <code>Y</code> and <code>Z</code> would contain <code>type u</code>.</p><p>There is logic in odoc to handle this correctly, but since there is currently no syntax for representing transparent ascription, the consequence is that we lose the fact that <code>Y</code> and <code>Z</code> originally came from <code>module type of</code> expressions.</p><p>This example is rendered <a href="odoc_examples/Odoc_examples/Expansion/ModuleTypeOfComplications/index.html">here</a>, and in the <a href="odoc_examples/Odoc_examples/Expansion/ModuleTypeOfComplications/module-type-T/index.html">expansion of T</a> it can be seen that <code>Y</code> and <code>Z</code> are simple signatures only containing type t.</p><h2 id="resolution"><a href="#resolution" class="anchor"></a>Resolution</h2><p>There are several different but related constructs for referring to elements in odoc. The following example demonstrates each:</p><pre><code>(** The module {!module-M} and type {!module-M.module-X.type-t} *)
module M : A.B.C with type X.t = int</code></pre><p>Here, <code>M</code> is an <em>identifier</em> that uniquely identifies the module <code>M</code>. <code>A.B.C</code> is a <em>path</em> used to locate a particular identifier, <code>X.t</code> is a <em>fragment</em> that refers to an element within a module type, and <code>module-M</code> and <code>module-M.module-X.type-t</code> are <em>references</em> that are similar to paths in that they are used to locate particular identifiers, but unlike paths they are not checked by the compiler and are entirely resolved by odoc.</p><p>In most of the output formats odoc supports, paths, references and fragments will be turned into links that take the reader to the identifier being referred to. These links necessarily need to take into account some of the features of expansions as outlined above. In order to decide where the links should point to and how to turn them into text, a process called 'Resolution' is required.</p><h3 id="aliases"><a href="#aliases" class="anchor"></a>Aliases</h3><p>Since aliases are not usually expanded, a path or reference to an item that is in an module that's an alias must link to the item in the aliased module instead. For example, given the following:</p><pre><code>module A : sig
  type t
end

module B = A

type t = B.t</code></pre><p>The right-hand side of type <code>t</code> should render as <code>B.t</code>, but it should link to the definition of <code>t</code> in module <code>A</code>. This example is demonstrated <a href="odoc_examples/Odoc_examples/Resolution/Alias/index.html">here</a>.</p><p>Aliases of hidden module <em>are</em> expanded, so the following example demonstrates this alteration:</p><pre><code>(**/**)

module A : sig
  type t
end

(**/**)

module B = A
  
type t = B.t</code></pre><p>Here we've hidden <code>A</code> via the <a href="https://ocaml.org/manual/ocamldoc.html#ss:ocamldoc-stop">documentation stop comment</a> mechanism. This example is demonstrated <a href="odoc_examples/Odoc_examples/Resolution/HiddenAlias/index.html">here</a>.</p><h3 id="canonical-paths"><a href="#canonical-paths" class="anchor"></a>Canonical paths</h3><p>When encountering a module, module type or a type that has been marked with a <code>@canonical</code> tag, odoc first has to check that the specified canonical path actually resolves. If this is the case, in a similar way to the alias above, the target of the path will be rewritten to point to the canonical path. However, in contrast to the alias behaviour, the <em>text</em> of the path will also be rewritten, so it will be as if the canonical path had been written instead of whatever path was actually there.</p><p>For example:</p><pre><code>module A : sig
  (** @canonical Odoc_examples.Resolution.Canonical.B *)

  type t
end

module B = A

type t = A.t</code></pre><p>Note that in this example the <code>@canonical</code> tag has been given the path <code>Odoc_examples.Resolution.Canonical.B</code>. This <em>must</em> be the fully qualified path to the canonical item.</p><p>In this example, the right-hand side of <code>type t</code> will be rewritten such that it will be as if <code>B.t</code> had been written instead.</p><p>Note that canonical tags are only used when resolving <em>paths</em>, not fragments (which are relative anyway) nor references, which since they are written by the author are assumed to point to the correct destination.</p><h3 id="fragment-resolution"><a href="#fragment-resolution" class="anchor"></a>Fragment resolution</h3><p>Fragments are relative paths that appear in module type expressions when adding equations or substituting types or modules. For example:</p><pre><code>module type A = sig
  module B : sig
    type t
    val f : t -&gt; t
  end
end

module C : A with type B.t = int
module D : module type of C.B with type t := int</code></pre><p>In this expression the fragment <code>B.t</code> should link to the definition of <code>type t</code> inside module <code>B</code> inside module type <code>A</code>. The fragment <code>t</code> in the definition of module <code>D</code> should link to the definition of type <code>t</code> inside module <code>B</code> inside module <code>C</code>. Note that it can't link to <code>type t</code> in <code>D</code> since that type has been destroyed!</p><p>This example is rendered <a href="odoc_examples/Odoc_examples/Resolution/Fragments/index.html">here</a>.</p><h3 id="hidden-elements"><a href="#hidden-elements" class="anchor"></a>Hidden elements</h3><p>If there are paths that refer to hidden elements, these are removed from the interface unless there is an equal non-hidden type that can replace it. For example, in the following type definitions,</p><pre><code>(**/**)

type t = int
type u

(**/**)

type v = T of t
type w = U of u</code></pre><p><code>type v</code> will have a right-hand side of <code>T of int</code> as the hidden type <code>t</code> is equal to <code>int</code>, whereas there is no non-hidden type equivalent to <code>u</code> so the right-hand side of type <code>w</code> is omitted from the output.</p><h3 id="reference-resolution"><a href="#reference-resolution" class="anchor"></a>Reference resolution</h3><p>References are hand-written in comments and not evaluated in any way by the compiler.</p><pre><code>module type A = sig

  type t
  (** type [t] in module type [A] *)

end

module A : sig

  type t
  (** type [t] in module [A] *)

  module B : sig type t end
  module type B = sig type t end

end

(** We can refer unambiguously to {!module-type-A.t} in module type [A]
    or {!module-A.t} in module [A], and also where there are name clashes
    within the path: {!A.module-B.t} or {!A.module-type-B.t} *)</code></pre><p>This demonstrates that it is possible to refer to elements even when there is ambiguity if just the names were used. If odoc detects any ambiguity it will emit a warning.</p><h3 id="module-type-challenges"><a href="#module-type-challenges" class="anchor"></a>Module type challenges</h3><p>In some cases resolution can be more challenging than others. Consider this example:</p><pre><code>module type A = sig
  module M : sig module type S end
  module N : M.S
end

module B : sig module type S = sig type t end end

module C : A with module M = B with type N.t = int

type t = C.N.t</code></pre><p>In the expansion of module type <code>A</code>, module <code>N</code> has no expansion because module type <code>S</code> is abstract. Therefore in the definition of module <code>C</code>, the fragment <code>N.t</code> therefore cannot link to module <code>N</code> in module type <code>A</code>, but instead must link to module type <code>S</code> in module <code>B</code>.</p><p>This example is rendered <a href="odoc_examples/Odoc_examples/Resolution/Complicated_1/index.html">here</a>.</p><p>Now a very complicated example:</p><pre><code>module type Type = sig module type T end

module App : functor (T : Type) (F : Type -&gt; Type) (M : F(T).T) -&gt; F(T).T

module Bar : sig module type T = sig type bar end end

module Foo :
  functor (T : Type) -&gt; sig module type T = sig module Foo : T.T end end

module FooBarInt : sig module Foo : sig type bar = int end end

type t = App(Bar)(Foo)(FooBarInt).Foo.bar</code></pre><p>This one is left as an exercise to the reader! It can be seen rendered by odoc <a href="odoc_examples/Odoc_examples/Resolution/Complicated_2/index.html">here</a>.</p></div></body></html>